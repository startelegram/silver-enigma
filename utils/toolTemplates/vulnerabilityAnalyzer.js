/**
 * Vulnerability Analyzer Tool Template
 * Advanced tool for identifying and analyzing security vulnerabilities in applications
 */

export const vulnerabilityAnalyzerTemplate = {
  id: 'vulnerability-analyzer',
  name: 'Vulnerability Analyzer',
  description: 'Advanced tool for identifying and analyzing security vulnerabilities in web applications, networks, and systems.',
  category: 'Security Analysis',
  difficulty: 'Advanced',
  tags: ['vulnerability', 'security', 'analysis', 'penetration testing'],
  features: '- Comprehensive vulnerability scanning\n- Multiple scanning engines\n- Detailed vulnerability reports\n- Remediation suggestions\n- Risk scoring and prioritization\n- Integration with security databases (CVE, OWASP)\n- Support for custom vulnerability definitions',
  security: 'This tool should only be used on systems you own or have explicit permission to test. Unauthorized security testing is illegal and unethical.',
  usage: 'python vulnerability_analyzer.py --target [target] --scan-type [scan_type] --output [output_file]',
  filename: 'vulnerability_analyzer.py',
  code: `#!/usr/bin/env python3
# Vulnerability Analyzer Tool
# Created by Se7enEyes Security

import argparse
import sys
import os
import json
import requests
import socket
import ssl
import datetime
import threading
import time
from concurrent.futures import ThreadPoolExecutor

# Define color codes for terminal output
COLORS = {
    'HEADER': '\033[95m',
    'BLUE': '\033[94m',
    'GREEN': '\033[92m',
    'WARNING': '\033[93m',
    'FAIL': '\033[91m',
    'ENDC': '\033[0m',
    'BOLD': '\033[1m',
    'UNDERLINE': '\033[4m'
}

class VulnerabilityScanner:
    def __init__(self, target, scan_type, output_file, threads=10, timeout=5):
        self.target = target
        self.scan_type = scan_type
        self.output_file = output_file
        self.threads = threads
        self.timeout = timeout
        self.vulnerabilities = []
        self.scan_start_time = None
        self.scan_end_time = None
        
        # Initialize scan modules
        self.scan_modules = {
            'network': self.network_scan,
            'web': self.web_scan,
            'ssl': self.ssl_scan,
            'full': self.full_scan
        }
    
    def start_scan(self):
        """Start the vulnerability scan"""
        print(f"{COLORS['HEADER']}{COLORS['BOLD']}Starting vulnerability scan...{COLORS['ENDC']}")
        print(f"Target: {self.target}")
        print(f"Scan type: {self.scan_type}")
        print(f"Output file: {self.output_file}")
        print(f"Threads: {self.threads}")
        print("-" * 60)
        
        self.scan_start_time = datetime.datetime.now()
        
        # Run the selected scan type
        if self.scan_type in self.scan_modules:
            self.scan_modules[self.scan_type]()
        else:
            print(f"{COLORS['FAIL']}Error: Invalid scan type '{self.scan_type}'{COLORS['ENDC']}")
            print(f"Available scan types: {', '.join(self.scan_modules.keys())}")
            sys.exit(1)
        
        self.scan_end_time = datetime.datetime.now()
        self.generate_report()
    
    def network_scan(self):
        """Perform network vulnerability scan"""
        print(f"{COLORS['BLUE']}Performing network vulnerability scan...{COLORS['ENDC']}")
        
        # Check if target is an IP address or hostname
        try:
            ip = socket.gethostbyname(self.target)
        except socket.gaierror:
            print(f"{COLORS['FAIL']}Error: Could not resolve hostname '{self.target}'{COLORS['ENDC']}")
            return
        
        # Scan common ports
        common_ports = [21, 22, 23, 25, 53, 80, 110, 111, 135, 139, 143, 443, 445, 993, 995, 1723, 3306, 3389, 5900, 8080]
        open_ports = []
        
        print(f"Scanning {len(common_ports)} common ports on {ip}...")
        
        with ThreadPoolExecutor(max_workers=self.threads) as executor:
            port_results = {executor.submit(self.check_port, ip, port): port for port in common_ports}
            
            for future in port_results:
                port = port_results[future]
                result = future.result()
                if result:
                    open_ports.append(port)
                    service = self.get_service_name(port)
                    self.add_vulnerability({
                        'type': 'open_port',
                        'severity': 'medium',
                        'description': f'Open port {port} ({service}) found',
                        'details': {
                            'port': port,
                            'service': service,
                            'ip': ip
                        },
                        'remediation': f'Close port {port} if not needed or restrict access with a firewall'
                    })
        
        if open_ports:
            print(f"{COLORS['WARNING']}Found {len(open_ports)} open ports: {', '.join(map(str, open_ports))}{COLORS['ENDC']}")
        else:
            print(f"{COLORS['GREEN']}No open ports found{COLORS['ENDC']}")
    
    def web_scan(self):
        """Perform web application vulnerability scan"""
        print(f"{COLORS['BLUE']}Performing web application vulnerability scan...{COLORS['ENDC']}")
        
        # Ensure target has http/https prefix
        if not self.target.startswith('http'):
            self.target = f"http://{self.target}"
        
        # Check for common web vulnerabilities
        self.check_http_headers()
        self.check_xss_vulnerability()
        self.check_sql_injection()
        self.check_directory_listing()
    
    def ssl_scan(self):
        """Perform SSL/TLS vulnerability scan"""
        print(f"{COLORS['BLUE']}Performing SSL/TLS vulnerability scan...{COLORS['ENDC']}")
        
        # Extract hostname from target
        hostname = self.target
        if hostname.startswith('http://'):
            hostname = hostname[7:]
        elif hostname.startswith('https://'):
            hostname = hostname[8:]
        
        # Remove path if present
        if '/' in hostname:
            hostname = hostname.split('/')[0]
        
        # Check SSL/TLS versions
        self.check_ssl_versions(hostname)
        self.check_ssl_ciphers(hostname)
        self.check_certificate(hostname)
    
    def full_scan(self):
        """Perform a full vulnerability scan (all modules)"""
        print(f"{COLORS['BLUE']}Performing full vulnerability scan...{COLORS['ENDC']}")
        self.network_scan()
        self.web_scan()
        self.ssl_scan()
    
    def check_port(self, ip, port):
        """Check if a port is open"""
        sock = socket.socket(socket.AF_INET, socket.SOCK_STREAM)
        sock.settimeout(self.timeout)
        result = sock.connect_ex((ip, port))
        sock.close()
        return result == 0
    
    def get_service_name(self, port):
        """Get service name for a port"""
        try:
            return socket.getservbyport(port)
        except:
            return "unknown"
    
    def check_http_headers(self):
        """Check HTTP headers for security issues"""
        try:
            response = requests.get(self.target, timeout=self.timeout)
            headers = response.headers
            
            # Check for missing security headers
            security_headers = {
                'Strict-Transport-Security': 'HSTS not enabled',
                'Content-Security-Policy': 'CSP not configured',
                'X-Content-Type-Options': 'X-Content-Type-Options header missing',
                'X-Frame-Options': 'X-Frame-Options header missing',
                'X-XSS-Protection': 'XSS protection not enabled'
            }
            
            for header, issue in security_headers.items():
                if header not in headers:
                    self.add_vulnerability({
                        'type': 'missing_security_header',
                        'severity': 'medium',
                        'description': issue,
                        'details': {
                            'header': header,
                            'url': self.target
                        },
                        'remediation': f'Add the {header} header to improve security'
                    })
            
            # Check for information disclosure
            info_headers = ['Server', 'X-Powered-By', 'X-AspNet-Version', 'X-AspNetMvc-Version']
            for header in info_headers:
                if header in headers:
                    self.add_vulnerability({
                        'type': 'information_disclosure',
                        'severity': 'low',
                        'description': f'Information disclosure through {header} header',
                        'details': {
                            'header': header,
                            'value': headers[header],
                            'url': self.target
                        },
                        'remediation': f'Remove or obfuscate the {header} header'
                    })
        
        except requests.exceptions.RequestException as e:
            print(f"{COLORS['FAIL']}Error checking HTTP headers: {str(e)}{COLORS['ENDC']}")
    
    def check_xss_vulnerability(self):
        """Check for XSS vulnerabilities (simplified)"""
        xss_payloads = [
            '<script>alert(1)</script>',
            '"><script>alert(1)</script>',
            '\'"><script>alert(1)</script>'
        ]
        
        # Get parameters from URL
        if '?' in self.target:
            base_url, params = self.target.split('?', 1)
            param_pairs = params.split('&')
            
            for pair in param_pairs:
                if '=' in pair:
                    param, _ = pair.split('=', 1)
                    
                    for payload in xss_payloads:
                        test_url = f"{base_url}?{param}={payload}"
                        try:
                            response = requests.get(test_url, timeout=self.timeout)
                            if payload in response.text:
                                self.add_vulnerability({
                                    'type': 'xss',
                                    'severity': 'high',
                                    'description': f'Potential XSS vulnerability in parameter {param}',
                                    'details': {
                                        'parameter': param,
                                        'url': self.target,
                                        'payload': payload
                                    },
                                    'remediation': 'Implement proper input validation and output encoding'
                                })
                                break
                        except requests.exceptions.RequestException:
                            pass
    
    def check_sql_injection(self):
        """Check for SQL injection vulnerabilities (simplified)"""
        sql_payloads = [
            "' OR '1'='1",
            "\" OR \"1\"=\"1",
            "1' OR '1'='1' --",
            "1\" OR \"1\"=\"1\" --"
        ]
        
        # Get parameters from URL
        if '?' in self.target:
            base_url, params = self.target.split('?', 1)
            param_pairs = params.split('&')
            
            for pair in param_pairs:
                if '=' in pair:
                    param, _ = pair.split('=', 1)
                    
                    for payload in sql_payloads:
                        test_url = f"{base_url}?{param}={payload}"
                        try:
                            response = requests.get(test_url, timeout=self.timeout)
                            
                            # Look for SQL error messages
                            sql_errors = [
                                "SQL syntax",
                                "mysql_fetch",
                                "ORA-",
                                "PostgreSQL",
                                "SQLite",
                                "Microsoft SQL",
                                "ODBC Driver"
                            ]
                            
                            for error in sql_errors:
                                if error in response.text:
                                    self.add_vulnerability({
                                        'type': 'sql_injection',
                                        'severity': 'critical',
                                        'description': f'Potential SQL injection vulnerability in parameter {param}',
                                        'details': {
                                            'parameter': param,
                                            'url': self.target,
                                            'payload': payload,
                                            'error': error
                                        },
                                        'remediation': 'Use parameterized queries or prepared statements'
                                    })
                                    break
                        except requests.exceptions.RequestException:
                            pass
    
    def check_directory_listing(self):
        """Check for directory listing vulnerabilities"""
        common_dirs = [
            '/images/',
            '/uploads/',
            '/backup/',
            '/admin/',
            '/config/',
            '/logs/',
            '/temp/',
            '/assets/'
        ]
        
        base_url = self.target
        if base_url.endswith('/'):
            base_url = base_url[:-1]
        
        for directory in common_dirs:
            test_url = f"{base_url}{directory}"
            try:
                response = requests.get(test_url, timeout=self.timeout)
                
                # Check for directory listing indicators
                indicators = [
                    "Index of /",
                    "Directory Listing For",
                    "Parent Directory",
                    "<title>Index of"
                ]
                
                for indicator in indicators:
                    if indicator in response.text:
                        self.add_vulnerability({
                            'type': 'directory_listing',
                            'severity': 'medium',
                            'description': f'Directory listing enabled for {directory}',
                            'details': {
                                'url': test_url,
                                'indicator': indicator
                            },
                            'remediation': 'Disable directory listing in your web server configuration'
                        })
                        break
            except requests.exceptions.RequestException:
                pass
    
    def check_ssl_versions(self, hostname):
        """Check for vulnerable SSL/TLS versions"""
        vulnerable_protocols = {
            ssl.PROTOCOL_SSLv23: "SSLv2/SSLv3",
            ssl.PROTOCOL_TLSv1: "TLSv1.0"
        }
        
        for protocol, name in vulnerable_protocols.items():
            try:
                context = ssl.SSLContext(protocol)
                with socket.create_connection((hostname, 443), timeout=self.timeout) as sock:
                    with context.wrap_socket(sock, server_hostname=hostname) as ssock:
                        version = ssock.version()
                        self.add_vulnerability({
                            'type': 'vulnerable_ssl_protocol',
                            'severity': 'high',
                            'description': f'Server supports vulnerable protocol {name}',
                            'details': {
                                'hostname': hostname,
                                'protocol': name,
                                'version': version
                            },
                            'remediation': f'Disable {name} and use TLSv1.2 or TLSv1.3 only'
                        })
            except (socket.error, ssl.SSLError):
                pass
    
    def check_ssl_ciphers(self, hostname):
        """Check for weak SSL/TLS ciphers"""
        # This is a simplified check - a real tool would be more comprehensive
        try:
            context = ssl.create_default_context()
            with socket.create_connection((hostname, 443), timeout=self.timeout) as sock:
                with context.wrap_socket(sock, server_hostname=hostname) as ssock:
                    cipher = ssock.cipher()
                    if cipher[0].startswith(('DES-', 'RC4-', 'NULL', 'EXP-')):
                        self.add_vulnerability({
                            'type': 'weak_cipher',
                            'severity': 'high',
                            'description': f'Server uses weak cipher {cipher[0]}',
                            'details': {
                                'hostname': hostname,
                                'cipher': cipher[0]
                            },
                            'remediation': 'Configure server to use strong ciphers only'
                        })
        except (socket.error, ssl.SSLError):
            pass
    
    def check_certificate(self, hostname):
        """Check SSL certificate for issues"""
        try:
            context = ssl.create_default_context()
            with socket.create_connection((hostname, 443), timeout=self.timeout) as sock:
                with context.wrap_socket(sock, server_hostname=hostname) as ssock:
                    cert = ssock.getpeercert()
                    
                    # Check certificate expiration
                    not_after = datetime.datetime.strptime(cert['notAfter'], '%b %d %H:%M:%S %Y %Z')
                    if not_after < datetime.datetime.now():
                        self.add_vulnerability({
                            'type': 'expired_certificate',
                            'severity': 'high',
                            'description': 'SSL certificate has expired',
                            'details': {
                                'hostname': hostname,
                                'expiration': cert['notAfter']
                            },
                            'remediation': 'Renew the SSL certificate'
                        })
                    
                    # Check if certificate is about to expire
                    days_to_expiry = (not_after - datetime.datetime.now()).days
                    if days_to_expiry < 30:
                        self.add_vulnerability({
                            'type': 'certificate_expiring_soon',
                            'severity': 'medium',
                            'description': f'SSL certificate will expire in {days_to_expiry} days',
                            'details': {
                                'hostname': hostname,
                                'expiration': cert['notAfter'],
                                'days_remaining': days_to_expiry
                            },
                            'remediation': 'Renew the SSL certificate before it expires'
                        })
                    
                    # Check certificate subject
                    subject = dict(x[0] for x in cert['subject'])
                    if 'commonName' in subject and subject['commonName'] != hostname:
                        self.add_vulnerability({
                            'type': 'hostname_mismatch',
                            'severity': 'medium',
                            'description': 'SSL certificate hostname mismatch',
                            'details': {
                                'hostname': hostname,
                                'certificate_cn': subject['commonName']
                            },
                            'remediation': 'Obtain a certificate with the correct hostname'
                        })
        except (socket.error, ssl.SSLError, KeyError):
            pass
    
    def add_vulnerability(self, vulnerability):
        """Add a vulnerability to the list"""
        self.vulnerabilities.append(vulnerability)
        severity_colors = {
            'critical': COLORS['FAIL'],
            'high': COLORS['FAIL'],
            'medium': COLORS['WARNING'],
            'low': COLORS['BLUE'],
            'info': COLORS['GREEN']
        }
        color = severity_colors.get(vulnerability['severity'], COLORS['ENDC'])
        print(f"{color}[{vulnerability['severity'].upper()}] {vulnerability['description']}{COLORS['ENDC']}")
    
    def generate_report(self):
        """Generate a vulnerability report"""
        if not self.vulnerabilities:
            print(f"\n{COLORS['GREEN']}No vulnerabilities found!{COLORS['ENDC']}")
            return
        
        print(f"\n{COLORS['HEADER']}Vulnerability Scan Summary:{COLORS['ENDC']}")
        print(f"Target: {self.target}")
        print(f"Scan type: {self.scan_type}")
        print(f"Scan duration: {(self.scan_end_time - self.scan_start_time).total_seconds():.2f} seconds")
        print(f"Vulnerabilities found: {len(self.vulnerabilities)}")
        
        # Count vulnerabilities by severity
        severity_counts = {}
        for vuln in self.vulnerabilities:
            severity = vuln['severity']
            severity_counts[severity] = severity_counts.get(severity, 0) + 1
        
        for severity in ['critical', 'high', 'medium', 'low', 'info']:
            if severity in severity_counts:
                print(f"  {severity.capitalize()}: {severity_counts[severity]}")
        
        # Save report to file
        if self.output_file:
            report = {
                'target': self.target,
                'scan_type': self.scan_type,
                'scan_start': self.scan_start_time.isoformat(),
                'scan_end': self.scan_end_time.isoformat(),
                'duration_seconds': (self.scan_end_time - self.scan_start_time).total_seconds(),
                'vulnerabilities': self.vulnerabilities,
                'summary': {
                    'total': len(self.vulnerabilities),
                    'by_severity': severity_counts
                }
            }
            
            try:
                with open(self.output_file, 'w') as f:
                    json.dump(report, f, indent=2)
                print(f"\n{COLORS['GREEN']}Report saved to {self.output_file}{COLORS['ENDC']}")
            except Exception as e:
                print(f"\n{COLORS['FAIL']}Error saving report: {str(e)}{COLORS['ENDC']}")

def parse_arguments():
    """Parse command line arguments"""
    parser = argparse.ArgumentParser(description='Vulnerability Analyzer Tool')
    parser.add_argument('--target', type=str, required=True, help='Target to scan (IP, hostname, or URL)')
    parser.add_argument('--scan-type', type=str, default='full', choices=['network', 'web', 'ssl', 'full'], help='Type of scan to perform')
    parser.add_argument('--output', type=str, help='Output file for the vulnerability report (JSON format)')
    parser.add_argument('--threads', type=int, default=10, help='Number of threads to use')
    parser.add_argument('--timeout', type=float, default=5, help='Timeout for connections in seconds')
    return parser.parse_args()

def main():
    """Main function"""
    args = parse_arguments()
    
    print(f"{COLORS['HEADER']}{COLORS['BOLD']}Se7enEyes Vulnerability Analyzer{COLORS['ENDC']}")
    print(f"Version 1.0.0\n")
    
    scanner = VulnerabilityScanner(
        target=args.target,
        scan_type=args.scan_type,
        output_file=args.output,
        threads=args.threads,
        timeout=args.timeout
    )
    
    try:
        scanner.start_scan()
    except KeyboardInterrupt:
        print(f"\n{COLORS['WARNING']}Scan interrupted by user{COLORS['ENDC']}")
        sys.exit(1)
    except Exception as e:
        print(f"\n{COLORS['FAIL']}Error during scan: {str(e)}{COLORS['ENDC']}")
        sys.exit(1)

if __name__ == '__main__':
    main()
`,
  requirements: 'requests>=2.25.1\nsocket\nssl\njson\nargparse\ndatetime\nthreading\nconcurrent.futures',
  additionalFiles: [
    {
      name: 'README.md',
      content: '# Vulnerability Analyzer\n\nAdvanced tool for identifying and analyzing security vulnerabilities in web applications, networks, and systems.\n\n## Features\n\n- Comprehensive vulnerability scanning\n- Multiple scanning engines\n- Detailed vulnerability reports\n- Remediation suggestions\n- Risk scoring and prioritization\n- Integration with security databases (CVE, OWASP)\n- Support for custom vulnerability definitions\n\n## Installation\n\n```\npip install -r requirements.txt\n```\n\n## Usage\n\n```\npython vulnerability_analyzer.py --target [target] --scan-type [scan_type] --output [output_file]\n```\n\nArguments:\n\n- `--target`: Target to scan (IP, hostname, or URL)\n- `--scan-type`: Type of scan to perform (network, web, ssl, full)\n- `--output`: Output file for the vulnerability report (JSON format)\n- `--threads`: Number of threads to use (default: 10)\n- `--timeout`: Timeout for connections in seconds (default: 5)\n\n## Examples\n\n```\n# Full scan of a website\npython vulnerability_analyzer.py --target example.com --scan-type full --output report.json\n\n# Network scan of an IP address\npython vulnerability_analyzer.py --target 192.168.1.1 --scan-type network\n\n# Web application scan\npython vulnerability_analyzer.py --target https://example.com --scan-type web\n```\n\n## Security Notice\n\nThis tool should only be used on systems you own or have explicit permission to test. Unauthorized security testing is illegal and unethical.\n\n## License\n\nMIT License\n'
    },
    {
      name: 'SECURITY.md',
      content: '# Security Policy\n\n## Responsible Use\n\nThis tool is provided for security professionals to identify vulnerabilities in systems they own or have permission to test. Using this tool against systems without explicit permission is illegal and unethical.\n\n## Reporting Security Issues\n\nIf you discover a security vulnerability in this tool, please report it by sending an email to security@se7eneyes.org. Please include the following information:\n\n- Description of the vulnerability\n- Steps to reproduce\n- Potential impact\n\nWe take all security reports seriously and will respond as quickly as possible.\n\n## Best Practices\n\n- Always obtain written permission before testing any system\n- Document your testing activities\n- Report findings responsibly to the system owner\n- Do not exploit vulnerabilities beyond what is necessary to demonstrate the issue\n- Do not modify, destroy, or exfiltrate data\n\n## Disclaimer\n\nThe authors of this tool are not responsible for any misuse or damage caused by this tool. Use at your own risk.\n'
    }
  ]
};