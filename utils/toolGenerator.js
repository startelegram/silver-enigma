/**
 * Utility functions for generating tool content based on tool name
 */

/**
 * Generates content for a tool based on its name and customization options
 * @param {string} toolName - The name of the tool to generate content for
 * @param {Object} customizationOptions - Options for customizing the tool
 * @returns {Object} - Object containing tool content details
 */
export function generateToolContent(toolName, customizationOptions = {}) {
  // Default values
  let toolContent = {
    description: 'A security tool generated by Se7enEyes',
    usage: 'Follow the instructions in the README file to use this tool.',
    filename: 'main.py',
    code: '',
    requirements: '',
    features: '',
    security: 'Use this tool responsibly and ethically.',
    additionalFiles: [],
    license: null
  };

  // Apply customizations if provided
  if (customizationOptions) {
    // Override default values with customization options
    toolContent = { ...toolContent, ...customizationOptions };
  }

  // Customize based on tool name
  switch(toolName.toLowerCase()) {
    case 'password-cracker':
      toolContent = {
        ...toolContent,
        description: 'A tool for testing password strength through various cracking methods including dictionary attacks, brute force, and rainbow tables.',
        usage: 'python main.py --wordlist [path_to_wordlist] --hash [hash_to_crack] --type [hash_type]',
        filename: 'password_cracker.py',
        features: '- Multiple attack methods (dictionary, brute force, hybrid)\n- Support for common hash formats (MD5, SHA1, SHA256, bcrypt)\n- Customizable character sets and masks\n- Performance optimization for GPU acceleration',
        security: 'This tool is intended for security professionals to test password strength. Unauthorized use against systems without permission is illegal and unethical.',
        code: `#!/usr/bin/env python3
# Password Cracking Tool
# Created by Se7enEyes Security

import argparse
import hashlib
import time
import os
from concurrent.futures import ThreadPoolExecutor

def parse_arguments():
    parser = argparse.ArgumentParser(description='Password Cracking Tool')
    parser.add_argument('--wordlist', type=str, help='Path to wordlist file')
    parser.add_argument('--hash', type=str, help='Hash to crack')
    parser.add_argument('--type', type=str, default='md5', help='Hash type (md5, sha1, sha256)')
    parser.add_argument('--threads', type=int, default=4, help='Number of threads to use')
    return parser.parse_args()

def hash_password(password, hash_type):
    """Hash a password using the specified algorithm"""
    password_bytes = password.encode('utf-8')
    if hash_type.lower() == 'md5':
        return hashlib.md5(password_bytes).hexdigest()
    elif hash_type.lower() == 'sha1':
        return hashlib.sha1(password_bytes).hexdigest()
    elif hash_type.lower() == 'sha256':
        return hashlib.sha256(password_bytes).hexdigest()
    else:
        raise ValueError(f"Unsupported hash type: {hash_type}")

def crack_password(wordlist_path, target_hash, hash_type, num_threads):
    """Attempt to crack a password hash using a wordlist"""
    if not os.path.exists(wordlist_path):
        print(f"Error: Wordlist file '{wordlist_path}' not found.")
        return None
    
    print(f"Starting password cracking with {num_threads} threads...")
    start_time = time.time()
    
    with open(wordlist_path, 'r', errors='ignore') as wordlist_file:
        words = [line.strip() for line in wordlist_file]
    
    total_words = len(words)
    print(f"Loaded {total_words} words from wordlist.")
    
    def check_password(password):
        hashed = hash_password(password, hash_type)
        if hashed == target_hash.lower():
            return password
        return None
    
    with ThreadPoolExecutor(max_workers=num_threads) as executor:
        results = list(executor.map(check_password, words))
    
    # Filter out None results
    matches = [result for result in results if result is not None]
    
    elapsed_time = time.time() - start_time
    print(f"Completed in {elapsed_time:.2f} seconds.")
    
    if matches:
        return matches[0]
    return None

def main():
    args = parse_arguments()
    
    if not args.hash:
        print("Error: No hash provided. Use --hash to specify a hash to crack.")
        return
    
    if not args.wordlist:
        print("Error: No wordlist provided. Use --wordlist to specify a wordlist file.")
        return
    
    print(f"Target hash: {args.hash}")
    print(f"Hash type: {args.type}")
    print(f"Wordlist: {args.wordlist}")
    
    password = crack_password(args.wordlist, args.hash, args.type, args.threads)
    
    if password:
        print(f"\nPassword found: {password}")
    else:
        print("\nPassword not found in wordlist.")

if __name__ == '__main__':
    main()
`,
        requirements: 'argparse\nhashlib\nconcurrent.futures'
      };
      break;
      
    case 'network-scanner':
      toolContent = {
        description: 'A network scanning tool that identifies open ports and services on target systems.',
        usage: 'python main.py --target [ip_address] --ports [port_range]',
        filename: 'network_scanner.py',
        code: `#!/usr/bin/env python3
# Network Scanner Tool
# Created by Se7enEyes Security

import argparse
import socket
import ipaddress
import threading
import time
from concurrent.futures import ThreadPoolExecutor

def parse_arguments():
    parser = argparse.ArgumentParser(description='Network Scanner Tool')
    parser.add_argument('--target', type=str, required=True, help='Target IP address or network range (CIDR notation)')
    parser.add_argument('--ports', type=str, default='1-1000', help='Port range to scan (e.g., 1-1000 or 22,80,443)')
    parser.add_argument('--threads', type=int, default=10, help='Number of threads to use')
    parser.add_argument('--timeout', type=float, default=1.0, help='Timeout for connections in seconds')
    return parser.parse_args()

def parse_port_range(port_range):
    """Parse port range string into a list of ports"""
    ports = []
    for part in port_range.split(','):
        if '-' in part:
            start, end = map(int, part.split('-'))
            ports.extend(range(start, end + 1))
        else:
            ports.append(int(part))
    return ports

def scan_port(ip, port, timeout):
    """Scan a single port on the specified IP"""
    sock = socket.socket(socket.AF_INET, socket.SOCK_STREAM)
    sock.settimeout(timeout)
    result = sock.connect_ex((ip, port))
    sock.close()
    
    if result == 0:
        try:
            service = socket.getservbyport(port)
        except:
            service = "unknown"
        return port, service
    return None

def scan_host(ip, ports, timeout, threads):
    """Scan specified ports on a host"""
    print(f"\nScanning {ip}...")
    open_ports = []
    
    with ThreadPoolExecutor(max_workers=threads) as executor:
        scan_tasks = []
        for port in ports:
            scan_tasks.append(executor.submit(scan_port, ip, port, timeout))
        
        for task in scan_tasks:
            result = task.result()
            if result:
                open_ports.append(result)
    
    return open_ports

def main():
    args = parse_arguments()
    ports = parse_port_range(args.ports)
    
    print(f"Se7enEyes Network Scanner")
    print(f"Target: {args.target}")
    print(f"Ports: {args.ports} ({len(ports)} ports)")
    print(f"Threads: {args.threads}")
    
    start_time = time.time()
    
    try:
        # Check if target is a network range or single IP
        if '/' in args.target:
            network = ipaddress.ip_network(args.target, strict=False)
            hosts = list(network.hosts())
            print(f"Scanning {len(hosts)} hosts in network {args.target}")
            
            all_results = {}
            for host in hosts:
                ip = str(host)
                results = scan_host(ip, ports, args.timeout, args.threads)
                if results:
                    all_results[ip] = results
        else:
            # Single IP
            results = scan_host(args.target, ports, args.timeout, args.threads)
            all_results = {args.target: results} if results else {}
        
        # Print results
        print("\nScan Results:")
        for ip, open_ports in all_results.items():
            print(f"\nHost: {ip}")
            if open_ports:
                print("Open ports:")
                for port, service in open_ports:
                    print(f"  {port}/tcp\t{service}")
            else:
                print("No open ports found.")
        
        elapsed_time = time.time() - start_time
        print(f"\nScan completed in {elapsed_time:.2f} seconds.")
        
    except Exception as e:
        print(f"Error: {e}")

if __name__ == '__main__':
    main()
`,
        requirements: 'socket\nipaddress\nthreading\nconcurrent.futures'
      };
      break;
      
    case 'vulnerability-scanner':
      toolContent = {
        description: 'A tool for scanning web applications for common security vulnerabilities.',
        usage: 'python main.py --url [target_url] --scan-type [scan_type]',
        filename: 'vulnerability_scanner.py',
        code: `#!/usr/bin/env python3
# Web Application Vulnerability Scanner
# Created by Se7enEyes Security

import argparse
import requests
import re
import urllib.parse
from concurrent.futures import ThreadPoolExecutor
from bs4 import BeautifulSoup

class VulnerabilityScanner:
    def __init__(self, url, scan_type='all', threads=5, timeout=10):
        self.base_url = url
        self.scan_type = scan_type.lower()
        self.threads = threads
        self.timeout = timeout
        self.session = requests.Session()
        self.session.headers.update({
            'User-Agent': 'Se7enEyes-Vulnerability-Scanner/1.0',
        })
        self.visited_urls = set()
        self.forms = []
        self.vulnerabilities = []
    
    def crawl(self, url, depth=2):
        """Crawl the website to discover URLs and forms"""
        if depth <= 0 or url in self.visited_urls:
            return
        
        self.visited_urls.add(url)
        print(f"Crawling: {url}")
        
        try:
            response = self.session.get(url, timeout=self.timeout)
            if 'text/html' not in response.headers.get('Content-Type', ''):
                return
            
            soup = BeautifulSoup(response.text, 'html.parser')
            
            # Find all forms
            for form in soup.find_all('form'):
                form_info = {
                    'action': form.get('action', ''),
                    'method': form.get('method', 'get').lower(),
                    'inputs': []
                }
                
                # Get form action URL
                if form_info['action']:
                    if not form_info['action'].startswith(('http://', 'https://')):
                        form_info['action'] = urllib.parse.urljoin(url, form_info['action'])
                else:
                    form_info['action'] = url
                
                # Get form inputs
                for input_field in form.find_all(['input', 'textarea']):
                    input_type = input_field.get('type', '')
                    input_name = input_field.get('name', '')
                    
                    if input_name:
                        form_info['inputs'].append({
                            'name': input_name,
                            'type': input_type
                        })
                
                self.forms.append(form_info)
            
            # Find all links
            links = soup.find_all('a', href=True)
            for link in links:
                href = link['href']
                if not href.startswith(('http://', 'https://', '#', 'javascript:', 'mailto:')):
                    href = urllib.parse.urljoin(url, href)
                
                if href.startswith(self.base_url) and href not in self.visited_urls:
                    self.crawl(href, depth - 1)
        
        except Exception as e:
            print(f"Error crawling {url}: {e}")
    
    def scan_xss(self, form):
        """Scan for XSS vulnerabilities in a form"""
        xss_payloads = [
            '<script>alert("XSS")</script>',
            '"><script>alert("XSS")</script>',
            '<img src="x" onerror="alert(\'XSS\')">'  
        ]
        
        for payload in xss_payloads:
            data = {}
            for input_field in form['inputs']:
                if input_field['type'] not in ['submit', 'button', 'image']:
                    data[input_field['name']] = payload
            
            try:
                if form['method'] == 'post':
                    response = self.session.post(form['action'], data=data, timeout=self.timeout)
                else:
                    response = self.session.get(form['action'], params=data, timeout=self.timeout)
                
                # Check if the payload is reflected in the response
                if payload in response.text:
                    self.vulnerabilities.append({
                        'type': 'XSS',
                        'url': form['action'],
                        'method': form['method'],
                        'payload': payload,
                        'details': f"Reflected XSS found in {form['method']} form at {form['action']}"
                    })
                    return True
            except Exception as e:
                print(f"Error testing XSS on {form['action']}: {e}")
        
        return False
    
    def scan_sqli(self, form):
        """Scan for SQL Injection vulnerabilities in a form"""
        sqli_payloads = [
            "' OR '1'='1",
            "\" OR \"1\"=\"1",
            "1' OR '1'='1' --",
            "admin'--"
        ]
        
        for payload in sqli_payloads:
            data = {}
            for input_field in form['inputs']:
                if input_field['type'] not in ['submit', 'button', 'image']:
                    data[input_field['name']] = payload
            
            try:
                if form['method'] == 'post':
                    response = self.session.post(form['action'], data=data, timeout=self.timeout)
                else:
                    response = self.session.get(form['action'], params=data, timeout=self.timeout)
                
                # Check for SQL error messages
                sql_errors = [
                    "SQL syntax",
                    "mysql_fetch",
                    "ORA-",
                    "PostgreSQL",
                    "SQLite",
                    "Microsoft SQL Server"
                ]
                
                for error in sql_errors:
                    if error in response.text:
                        self.vulnerabilities.append({
                            'type': 'SQL Injection',
                            'url': form['action'],
                            'method': form['method'],
                            'payload': payload,
                            'details': f"Possible SQL Injection found in {form['method']} form at {form['action']}"
                        })
                        return True
            except Exception as e:
                print(f"Error testing SQL Injection on {form['action']}: {e}")
        
        return False
    
    def scan_form(self, form):
        """Scan a form for vulnerabilities"""
        if self.scan_type in ['all', 'xss']:
            self.scan_xss(form)
        
        if self.scan_type in ['all', 'sqli']:
            self.scan_sqli(form)
    
    def run_scan(self):
        """Run the vulnerability scan"""
        print(f"Starting vulnerability scan on {self.base_url}")
        print(f"Scan type: {self.scan_type}")
        
        # First crawl the website
        self.crawl(self.base_url)
        print(f"Crawling complete. Found {len(self.forms)} forms.")
        
        # Then scan each form for vulnerabilities
        with ThreadPoolExecutor(max_workers=self.threads) as executor:
            executor.map(self.scan_form, self.forms)
        
        # Print results
        print("\nScan Results:")
        if self.vulnerabilities:
            print(f"Found {len(self.vulnerabilities)} potential vulnerabilities:")
            for i, vuln in enumerate(self.vulnerabilities, 1):
                print(f"\n{i}. {vuln['type']}")
                print(f"   URL: {vuln['url']}")
                print(f"   Method: {vuln['method']}")
                print(f"   Payload: {vuln['payload']}")
                print(f"   Details: {vuln['details']}")
        else:
            print("No vulnerabilities found.")

def parse_arguments():
    parser = argparse.ArgumentParser(description='Web Application Vulnerability Scanner')
    parser.add_argument('--url', type=str, required=True, help='Target URL to scan')
    parser.add_argument('--scan-type', type=str, default='all', choices=['all', 'xss', 'sqli'], 
                        help='Type of scan to perform')
    parser.add_argument('--threads', type=int, default=5, help='Number of threads to use')
    parser.add_argument('--timeout', type=int, default=10, help='Request timeout in seconds')
    return parser.parse_args()

def main():
    args = parse_arguments()
    
    scanner = VulnerabilityScanner(
        url=args.url,
        scan_type=args.scan_type,
        threads=args.threads,
        timeout=args.timeout
    )
    
    scanner.run_scan()

if __name__ == '__main__':
    main()
`,
        requirements: 'requests\nbs4\nurllib3\nre'
      };
      break;
      
    default:
      // Generic security tool template
      toolContent = {
        description: `A security tool named ${toolName} generated by Se7enEyes.`,
        usage: `python ${toolName.toLowerCase().replace(/\s+/g, '_')}.py --help`,
        filename: `${toolName.toLowerCase().replace(/\s+/g, '_')}.py`,
        code: `#!/usr/bin/env python3
# ${toolName} - Security Tool
# Created by Se7enEyes Security

import argparse
import sys
import time

def parse_arguments():
    parser = argparse.ArgumentParser(description='${toolName} - Security Tool')
    parser.add_argument('--target', type=str, help='Target to analyze')
    parser.add_argument('--output', type=str, help='Output file for results')
    parser.add_argument('--verbose', action='store_true', help='Enable verbose output')
    return parser.parse_args()

def banner():
    print("""\n
    ███████╗███████╗███████╗███████╗███╗   ██╗███████╗██╗   ██╗███████╗███████╗
    ██╔════╝██╔════╝╚════██║██╔════╝████╗  ██║██╔════╝╚██╗ ██╔╝██╔════╝██╔════╝
    ███████╗█████╗    ███╔═╝█████╗  ██╔██╗ ██║█████╗   ╚████╔╝ █████╗  ███████╗
    ╚════██║██╔══╝   ███╔╝ ██╔══╝  ██║╚██╗██║██╔══╝    ╚██╔╝  ██╔══╝  ╚════██║
    ███████║███████╗███████╗███████╗██║ ╚████║███████╗   ██║   ███████╗███████║
    ╚══════╝╚══════╝╚══════╝╚══════╝╚═╝  ╚═══╝╚══════╝   ╚═╝   ╚══════╝╚══════╝
                                                                              
    ${toolName} - Security Tool
    Created by Se7enEyes Security
    """)

def main():
    banner()
    args = parse_arguments()
    
    if not args.target:
        print("Error: No target specified. Use --target to specify a target.")
        sys.exit(1)
    
    print(f"\n[+] Starting {toolName}")
    print(f"[+] Target: {args.target}")
    
    # Simulate tool execution
    print("\n[*] Initializing...")
    time.sleep(1)
    
    print("[*] Analyzing target...")
    time.sleep(2)
    
    print("[*] Processing results...")
    time.sleep(1)
    
    # Output results
    print("\n[+] Analysis complete!")
    print("\nResults:")
    print("--------")
    print(f"Target: {args.target}")
    print("Status: Scan completed successfully")
    print("Findings: No security issues detected")
    
    if args.output:
        print(f"\n[+] Saving results to {args.output}")
        # In a real tool, you would save results to the output file here
    
    print("\n[+] Thank you for using Se7enEyes Security Tools!")

if __name__ == '__main__':
    main()
`,
        requirements: 'argparse\ntime\nsys'
      };
  }

  return toolContent;
}